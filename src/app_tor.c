#include <sys_process.h>
#include <event2/event.h>
#include <helpers.h>
#include <sys_crash.h>
#include <stdio.h>
#include <constants.h>
#include <array.h>
#include <ui_logger.h>
#include <debug.h>
#include <unistd.h>
#include <fcntl.h>

#include <app.h>

// End win on crash
static void app_tor_crash(void *attr) {
    app_tor_end(attr);
}

// Handle tor error
static void tor_err(struct app_data *app, const char *err) {
    if (app->cf.is_mailbox) {
        sys_crash("Tor", err);
    }

    app_ui_info(app, "[Tor] error: %s", err);
    app_tor_end(app);
}

// Handle tor logs
static void tor_handle_output(evutil_socket_t fd, short what, void *arg) {
    int rc;
    char ch;
    struct app_data *app = arg;

    if (!app->tor_line_buffer)
        app->tor_line_buffer = array(char);

    while ((rc = read(app->tor_process->stdout_fd, &ch, 1)) > 0) {
        if (ch == '\n') {
            array_set(app->tor_line_buffer, app->tor_line_buffer_len, '\0');

            if (app->cf.is_mailbox)
                printf("[Tor] %s\n", app->tor_line_buffer);
            else
                app_ui_info(app, "[Tor] %s", app->tor_line_buffer);

            if (str_ends_with(app->tor_line_buffer, TOR_SUCCESS_LINE)) {
                app->tor_ready = 1;
                if (app->cf.is_mailbox)
                    printf("[Tor] client ready\n");
                else
                    ui_logger_log(app->ui.info, "[Tor] client ready");
            }

            app->tor_line_buffer_len = 0;
            continue;
        }

        array_set(app->tor_line_buffer, app->tor_line_buffer_len, ch);
        ++app->tor_line_buffer_len;
    }

    if (rc == -1 && errno != EAGAIN && errno != EWOULDBLOCK) {
        // Error reading from FD
        tor_err(app, "Failed to read output from tor process");
        sys_process_end(app->tor_process);
        app->tor_ready = 0;
    }
}

// Generate torrc, start tor client,
// also add input event to event loop to handle input from client
void app_tor_start(struct app_data *app) {
    int i;
    FILE *torrc;
    char **tor_args;
    int stdout_flags;

    if (app->tor_ready)
        return;

    debug("TOR START");
    
    if (get_free_port(app->cf.tor_port) == 0) {
        tor_err(app, "Failed to get free TCP port to start Tor client");
        return;
    }

    if (!(torrc = fopen(app->path.torrc, "w"))) {
        tor_err(app, "Failed to open and write to torrc file");
        return;
    }

    fprintf(torrc, "# Generated by Deep Messenger\n");
    fprintf(torrc, "# Any manual changes will be overwritten\n\n");
    fprintf(torrc, "SocksPort %s\n", app->cf.tor_port);
    fprintf(torrc, "DataDirectory %s\n", app->path.tor_data);
    fprintf(torrc, "HiddenServiceDir %s\n", app->path.onion_dir);

    fprintf(torrc, "HiddenServicePort %s 127.0.0.1:%s\n",
        app->cf.is_mailbox ? app->cf.mailbox_port : app->cf.app_port, app->cf.app_local_port);
    fclose(torrc);

    // Create args array for tor process
    tor_args = array(char*);
    array_expand(tor_args, 4);

    for (i = 0; i < 3; i++)
        tor_args[i] = array(char);

    array_strcpy(tor_args[0], "tor",           -1);
    array_strcpy(tor_args[1], "-f",            -1);
    array_strcpy(tor_args[2], app->path.torrc, -1);
    array_set(tor_args, 3, 0);

    debug("Tor arguments READY, starting path %s", app->path.tor_bin);

    // Start tor process
    app->tor_process = sys_process_start(app->path.tor_bin, tor_args, 0);

    for (i = 0; i < 3; i++)
        array_free(tor_args[i]);
    array_free(tor_args);

    if (!app->tor_process) {
        tor_err(app, "Failed to fork tor process");
        return;
    }

    // Make stdout FD nonblocking
    if (
        (stdout_flags = fcntl(app->tor_process->stdout_fd, F_GETFL)) == -1 ||
        fcntl(app->tor_process->stdout_fd, F_SETFL, stdout_flags | O_NONBLOCK)
    ) {
        tor_err(app, "Failed to set flags on tor FD");
        return;
    }

    app->tor_event = event_new(app->base, app->tor_process->stdout_fd,
        EV_READ|EV_PERSIST, tor_handle_output, app);
    event_add(app->tor_event, NULL);
    event_priority_set(app->tor_event, APP_EV_PRIORITY_NET);
}

// Stop tor process and associated event
void app_tor_end(struct app_data *app) {
    app->tor_ready = 0;

    if (app->tor_event) {
        event_del(app->tor_event);
        event_free(app->tor_event);
    }
    if (app->tor_process) {
        sys_process_end(app->tor_process);
    }

    app->tor_event = NULL;
    app->tor_process = NULL;
    app->tor_line_buffer_len = 0;
}